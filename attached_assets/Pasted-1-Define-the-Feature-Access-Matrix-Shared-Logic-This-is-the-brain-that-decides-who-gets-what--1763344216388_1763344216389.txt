1️⃣ Define the Feature Access Matrix (Shared Logic)

This is the brain that decides who gets what.

Create client/src/lib/featureAccess.ts (and you can mirror this on the server if you want shared logic):

// client/src/lib/featureAccess.ts
import type { LookupKey } from "@/data/planSkus";

// List every “feature flag” your app cares about
export type FeatureKey =
  | "weeklyMealBoard"
  | "macroCalculator"
  | "basicPresets"
  | "biometrics"
  | "cravingCreator"
  | "fridgeRescue"
  | "restaurantGuide"
  | "kidsHub"
  | "holidayPlanner"
  | "clinicalHubs"
  | "glp1Hub"
  | "diabeticHub"
  | "crohnsIbsHub"
  | "shoppingListExport"
  | "shoppingDelivery"
  | "proCollaboration"
  | "labValues"
  | "advancedAnalytics"
  | "medicalDietHub"
  | "eliteAthleteMode"
  | "voiceCommands";

type PlanKey = "basic" | "premium" | "ultimate";

const PLAN_BY_LOOKUP: Record<LookupKey, PlanKey> = {
  mpm_basic_monthly: "basic",
  mpm_premium_monthly: "premium",
  mpm_premium_beta_monthly: "premium",
  mpm_ultimate_monthly: "ultimate",
  mpm_family_base_monthly: "premium",            // families get at least Premium-level access
  mpm_family_all_premium_monthly: "premium",
  mpm_family_all_ultimate_monthly: "ultimate",
  mpm_procare_monthly: "ultimate",               // pro-linked clients should be on Ultimate
};

const FEATURE_ACCESS: Record<PlanKey, FeatureKey[]> = {
  basic: [
    "weeklyMealBoard",
    "macroCalculator",
    "basicPresets",
    "biometrics",
  ],
  premium: [
    "weeklyMealBoard",
    "macroCalculator",
    "basicPresets",
    "biometrics",
    "cravingCreator",
    "fridgeRescue",
    "restaurantGuide",
    "kidsHub",
    "holidayPlanner",
    "shoppingListExport",
    "clinicalHubs",
    "glp1Hub",
    "diabeticHub",
    "crohnsIbsHub",
  ],
  ultimate: [
    "weeklyMealBoard",
    "macroCalculator",
    "basicPresets",
    "biometrics",
    "cravingCreator",
    "fridgeRescue",
    "restaurantGuide",
    "kidsHub",
    "holidayPlanner",
    "shoppingListExport",
    "clinicalHubs",
    "glp1Hub",
    "diabeticHub",
    "crohnsIbsHub",
    "shoppingDelivery",
    "proCollaboration",
    "labValues",
    "advancedAnalytics",
    "medicalDietHub",
    "eliteAthleteMode",
    "voiceCommands",
  ],
};

export function getPlanKeyFromLookup(lookup?: LookupKey | null): PlanKey | null {
  if (!lookup) return null;
  return PLAN_BY_LOOKUP[lookup] ?? null;
}

export function hasFeatureAccess(lookup: LookupKey | null | undefined, feature: FeatureKey): boolean {
  const planKey = getPlanKeyFromLookup(lookup ?? undefined);
  if (!planKey) return false;
  return FEATURE_ACCESS[planKey].includes(feature);
}


Now in any component, you can do:

import { hasFeatureAccess } from "@/lib/featureAccess";
import { useAuth } from "@/contexts/AuthContext";

const { user } = useAuth();

if (!hasFeatureAccess(user?.planLookupKey, "cravingCreator")) {
  // show paywall instead of the real feature
}


Onboarding logic can use the same helper to decide whether to block.

2️⃣ Update planSkus.ts Prices to Match Your Final Numbers

You locked in:

Family Base → $39.99

Family All-Premium → $49.99

Family All-Ultimate → $79.99

Update your PLAN_SKUS to match:

  {
    sku: "mpm_family_base_monthly",
    label: "Family Base",
    price: 39.99,   // <-- updated
    seats: 4,
    group: "family",
    blurb: "One household, 4 profiles, shared menus & shopping",
    features: [
      "Includes up to 4 profiles",
      "Shared Smart Menu Builder",
      "Shared Shopping List",
      "Individual macro tracking per profile",
      "Parental controls"
    ],
    badge: "Best for Families"
  },
  {
    sku: "mpm_family_all_premium_monthly",
    label: "Family All-Premium",
    price: 49.99,   // <-- updated
    seats: 4,
    group: "family",
    blurb: "All 4 seats include Premium features",
    // ...
  },
  {
    sku: "mpm_family_all_ultimate_monthly",
    label: "Family All-Ultimate",
    price: 79.99,   // <-- updated
    seats: 4,
    group: "family",
    blurb: "All 4 seats include Ultimate features",
    // ...
  },


This keeps your UI in sync with Stripe.

3️⃣ Stripe Price Map (Backend Config)

Create server/config/stripePrices.ts (path can vary, but keep it under server):

// server/config/stripePrices.ts
import type { LookupKey } from "../../client/src/data/planSkus"; // adjust path if needed

export const STRIPE_PRICE_IDS: Record<LookupKey, string> = {
  mpm_basic_monthly:          "price_basic_XXXX",
  mpm_premium_monthly:        "price_premium_XXXX",
  mpm_premium_beta_monthly:   "price_beta_XXXX",
  mpm_ultimate_monthly:       "price_ultimate_XXXX",
  mpm_family_base_monthly:    "price_1SGls4JC1cXhpBKwB141c6aZ",
  mpm_family_all_premium_monthly: "price_1SGltpJC1cXhpBKwKqTOSUnj",
  mpm_family_all_ultimate_monthly: "price_1SGlx1JC1cXhpBKwIWjvKL8g",
  mpm_procare_monthly:        "price_procare_XXXX",
};


Swap the XXXX for the real price IDs you already set in Stripe.

4️⃣ Subscription Service (Drizzle + Express)

Create server/services/subscriptionService.ts:

// server/services/subscriptionService.ts
import { db } from "../db";
import { users } from "../db/schema/users"; // adjust to your actual users table
import { eq } from "drizzle-orm";
import type { LookupKey } from "../../client/src/data/planSkus";

export async function updateUserSubscription(opts: {
  userId: string;
  lookupKey: LookupKey;
  stripeCustomerId?: string;
  stripeSubscriptionId?: string;
}) {
  const { userId, lookupKey, stripeCustomerId, stripeSubscriptionId } = opts;

  await db
    .update(users)
    .set({
      planLookupKey: lookupKey,
      stripeCustomerId: stripeCustomerId ?? undefined,
      stripeSubscriptionId: stripeSubscriptionId ?? undefined,
      // optionally: subscriptionStatus, currentPeriodEnd, etc.
    })
    .where(eq(users.id, userId));
}


Adjust field names to match your users schema (id, planLookupKey, stripeCustomerId, etc.).

5️⃣ Checkout Route (Express + Stripe)

Create server/routes/stripeCheckout.ts:

// server/routes/stripeCheckout.ts
import { Router } from "express";
import Stripe from "stripe";
import { STRIPE_PRICE_IDS } from "../config/stripePrices";
import type { LookupKey } from "../../client/src/data/planSkus";
import { requireAuth } from "../middleware/requireAuth"; // adjust to your auth middleware

const router = Router();

const stripe = new Stripe(process.env.STRIPE_SECRET_KEY as string, {
  apiVersion: "2024-06-20", // or your current version
});

router.post(
  "/api/stripe/checkout",
  requireAuth,
  async (req, res) => {
    try {
      const { sku, context } = req.body as { sku: LookupKey; context?: string };
      const user = req.user; // from requireAuth

      const priceId = STRIPE_PRICE_IDS[sku];
      if (!priceId) {
        return res.status(400).json({ error: "Invalid SKU" });
      }

      const session = await stripe.checkout.sessions.create({
        mode: "subscription",
        payment_method_types: ["card"],
        line_items: [
          {
            price: priceId,
            quantity: 1,
          },
        ],
        customer_email: user.email,
        success_url: `${process.env.FRONTEND_URL}/billing/success?session_id={CHECKOUT_SESSION_ID}`,
        cancel_url: `${process.env.FRONTEND_URL}/billing/cancel`,
        metadata: {
          userId: user.id,
          sku,
          context: context ?? "unknown",
        },
      });

      return res.json({ url: session.url });
    } catch (err) {
      console.error("Stripe checkout error:", err);
      return res.status(500).json({ error: "Failed to create checkout session" });
    }
  }
);

export default router;


Then in server/index.ts (or wherever you wire routes):

import stripeCheckoutRouter from "./routes/stripeCheckout";

app.use(express.json()); // keep this ABOVE normal JSON routes
app.use(stripeCheckoutRouter);

6️⃣ Webhook Route (Express + Stripe)

Create server/routes/stripeWebhook.ts:

// server/routes/stripeWebhook.ts
import { Router } from "express";
import Stripe from "stripe";
import { updateUserSubscription } from "../services/subscriptionService";

const router = Router();

const stripe = new Stripe(process.env.STRIPE_SECRET_KEY as string, {
  apiVersion: "2024-06-20",
});

const webhookSecret = process.env.STRIPE_WEBHOOK_SECRET as string;

// IMPORTANT: this route MUST use express.raw in server/index.ts
router.post("/api/stripe/webhook", async (req, res) => {
  const sig = req.headers["stripe-signature"] as string;

  let event: Stripe.Event;

  try {
    event = stripe.webhooks.constructEvent(
      (req as any).rawBody, // provided by express.raw
      sig,
      webhookSecret
    );
  } catch (err: any) {
    console.error("❌ Webhook signature verification failed.", err.message);
    return res.status(400).send(`Webhook Error: ${err.message}`);
  }

  try {
    switch (event.type) {
      case "checkout.session.completed": {
        const session = event.data.object as Stripe.Checkout.Session;

        const metadata = session.metadata || {};
        const userId = metadata.userId;
        const sku = metadata.sku as any;

        if (!userId || !sku) break;

        const subscriptionId = session.subscription as string;
        const customerId = session.customer as string;

        await updateUserSubscription({
          userId,
          lookupKey: sku,
          stripeCustomerId: customerId,
          stripeSubscriptionId: subscriptionId,
        });

        break;
      }

      case "invoice.paid":
        // You can add renewal handling here later if needed
        break;

      case "customer.subscription.deleted":
        // Handle cancellations (optional for now)
        break;

      default:
        break;
    }

    res.json({ received: true });
  } catch (err) {
    console.error("Webhook handler error:", err);
    res.status(500).send("Webhook handler error");
  }
});

export default router;


In server/index.ts, wire it BEFORE express.json():

import stripeWebhookRouter from "./routes/stripeWebhook";
import express from "express";

app.post(
  "/api/stripe/webhook",
  express.raw({ type: "application/json" }),
  stripeWebhookRouter
);

// AFTER webhook:
app.use(express.json());


(Or adapt to how your index file is structured, but the key is: webhook route uses express.raw, normal routes use express.json.)

7️⃣ Frontend startCheckout Helper

You already import startCheckout in your pricing page. Here’s a solid implementation.

Create client/src/lib/checkout.ts:

// client/src/lib/checkout.ts
import axios from "axios";
import type { LookupKey } from "@/data/planSkus";

export async function startCheckout(
  sku: LookupKey,
  options?: { context?: string }
) {
  const res = await axios.post("/api/stripe/checkout", {
    sku,
    context: options?.context ?? "pricing_page",
  });

  if (res.data?.url) {
    window.location.href = res.data.url;
  } else {
    throw new Error("No checkout URL returned");
  }
}


That will make your existing PricingPage buttons actually DO something once the backend is wired.

8️⃣ What You’ve Got After This

Once you drop these pieces in (and tweak imports/paths):

Stripe checkout works

Webhook updates the user’s planLookupKey in Postgres

FeatureAccess matrix lets you gate UI and show paywalls

You can now easily add:

onboarding triggers (medical → Premium, pro-collab → Ultimate)

specific paywall components

family seat logic

ProCare wiring later

You’re no longer “just having a pricing page.”
You now have the skeleton of a real subscription engine.