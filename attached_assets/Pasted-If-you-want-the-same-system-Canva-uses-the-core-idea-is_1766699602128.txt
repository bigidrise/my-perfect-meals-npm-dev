If you want “the same system Canva uses,” the core idea is dead simple:

**Canva never “hotlinks” some temporary image URL and hopes it’s still alive tomorrow.** Canva *ingests the asset into Canva*, stores it in their own infrastructure, and then serves it back with a stable asset reference (asset ID → CDN URL). Their API even supports “upload an asset from a URL” as an async job—meaning they pull it in, store it, and manage it as a first-class asset. ([canva.dev][1])

So for My Perfect Meals, “Canva-style” means this:

### The Canva-style image lifecycle (what we implement)

1. **Generate or fetch image** (DALL·E, restaurant API, whatever).
2. **Immediately download it server-side** (never trust the provider URL to live).
3. **Store it in *our* object storage** (S3/R2/Replit Object Storage/etc.).
4. **Create an Asset record** in DB:

   * `asset_id`
   * `sha256` (dedupe)
   * `storage_key`
   * `cdn_url` (or signed URL policy)
   * `prompt / source / created_at`
   * `owner_type` + `owner_id` (meal, restaurant result, fridge rescue item, etc.)
5. **Every UI card renders from Asset → stable URL**, not from any transient third-party link.
6. **Fallback only if asset missing**, not because the URL expired.

### Why your current system feels “tacky”

Because some features are effectively doing:

* “Here’s a temporary OpenAI URL” → saved into a meal → looks fine for an hour → then expires → UI falls back to stock or blank.

That’s the opposite of Canva.

### The non-negotiable rules (so we stop revisiting this 20 times)

* **Rule #1:** No persisted record (meal/board/restaurant result) is allowed to store a third-party temp URL as its `imageUrl`.
* **Rule #2:** If an image is shown on a saved entity, it must point to a **first-party stored asset** (or a known permanent catalog image).
* **Rule #3:** Add a “gate” on save: if `imageUrl` isn’t first-party, **convert it** (download → upload → replace) before commit.

### What this gives you

* **Persistence:** images never disappear.
* **Consistency:** every feature behaves the same.
* **Speed:** CDN caching makes repeat views fast.
* **Accuracy control:** if chicken looks like sushi, you can regenerate and version it (asset v2) without breaking the meal.

If you want, I’ll write the **architect prompt** that forces him to map the current flows (which endpoints/components bypass permanent storage), and then implement the “Canva gate” in the save pipeline so nothing transient can ever leak into Weekly Boards / Meals Near Me / Restaurant Guide again.

[1]: https://www.canva.dev/docs/connect/api-reference/assets/create-url-asset-upload-job/?utm_source=chatgpt.com "Create asset upload job via URL"
