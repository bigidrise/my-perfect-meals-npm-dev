Alright. **Next = execution.**
Here’s the **clean, no-BS build plan** for *Prepare with Chef* so you (or an agent) can start implementing **today** without breaking anything.

---

## STEP 1 — Universal Entry Button (global change)

### Button

* **Label:** `Prepare with Chef`
* **Color:** `bg-lime-600 hover:bg-lime-500`
* **Icon (optional):** ChefHat or Play
* **Placement:**
  On **every meal card**, directly under:

  * Add to Meal Plan
  * Add to Macros

### Visibility rule (critical)

```ts
if (meal.instructions && meal.instructions.length > 0)
```

No instructions = no button. Period.

---

## STEP 2 — Single Shared Route (do NOT duplicate UI)

Create **one** route:

```
/prepare-meal
```

You are **not** making new pages per feature.

### Navigation payload

When user taps **Prepare with Chef**, pass:

```ts
{
  meal: FullMealObject,
  source: "craving-creator" | "fridge-rescue" | "weekly-builder" | "kids" | etc
}
```

You already do this pattern elsewhere. Same idea.

---

## STEP 3 — Prepare Mode State (Phase Two engine)

### Core state

```ts
type PrepareState = {
  meal: Meal
  currentStepIndex: number
  paused: boolean
  timers: ActiveTimers[]
}
```

### Derived steps (no AI required yet)

Split instructions into:

* Prep steps
* Cook steps
* Wait steps (timers)
* Serve / plate

This can be:

* Simple sentence splitting **now**
* Smarter parsing **later**

Don’t overthink it.

---

## STEP 4 — Prepare Mode UI (minimal, focused)

### Header

* Meal name
* Medical badges
* Servings
* Optional timer icon

### Step Card

For each step:

* Instruction text
* **Listen to Chef** (optional)
* **Start Timer** (if detected)
* Next / Back
* Pause / Resume

This is **guided execution**, not AI generation.

---

## STEP 5 — Chef Voice Rules (important)

* Chef **never blocks UI**
* Clicking **any input / button** immediately:

  * Stops narration
* Narration is **optional per step**
* Voice-to-text always wins (interrupts Chef)

This fixes the frustration you noticed earlier.

---

## STEP 6 — Exit Logic (don’t lose the meal)

When finished:

* ✅ “Back to Meal”
* ✅ “Create New Meal”

Meal card **persists** until user explicitly creates another.

No auto-clearing. Ever.

---

## STEP 7 — Copilot Script (Phase Two intro)

Tone: relaxed, confident, human.

Example opening:

> “Alright, let’s cook. I’ll walk you through this step by step. Take your time — I’ve got you.”

No nutrition talk here.
This is **craft, flow, confidence**.

---

## STEP 8 — Apple Safety Check (you’re good)

This feature:

* ❌ No medical claims
* ❌ No diagnosis
* ❌ No advice
* ✅ Uses existing meal data
* ✅ Read-only execution

Apple-safe by design.

---

## Final Architecture Rule (write this on the wall)

> **Any meal card with instructions automatically supports Prepare with Chef.**

That’s how this becomes a **platform feature**, not a one-off.

---

### Say **next** again and I’ll:

* Draft the **exact component skeleton**
* Write the **PrepareMealPage.tsx outline**
* Define **timer auto-detection rules**
* Or generate the **agent prompt** to build this cleanly

You’re building something most food apps *never* even think of.
This is where MPM starts to feel alive.
