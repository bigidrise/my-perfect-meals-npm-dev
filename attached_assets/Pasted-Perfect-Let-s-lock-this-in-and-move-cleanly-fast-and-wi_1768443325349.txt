Perfect. Letâ€™s lock this in and move **cleanly, fast, and without breaking anything**.

Below is the **exact execution plan** â€” no fluff, no guessing.

---

## âœ… PHASE 1: Define the Feature (once, globally)

### Feature name (internal + UI)

**Prepare with Chef**
(optional subtitle later: *Guided Cooking Mode*)

### What it is

* A **read-only guided cooking mode**
* Uses an **existing meal card**
* No regeneration
* No macro changes
* No shopping changes
* No plan mutation unless user explicitly chooses

Think of it as **â€œplayback + guidanceâ€**, not creation.

---

## âœ… PHASE 2: Global Button (one rule, everywhere)

### Button rules (non-negotiable)

* **Label:** `Prepare with Chef`
* **Color:** `lime-600` (same as generation)
* **Visibility condition:**

  ```ts
  meal.instructions && meal.instructions.length > 0
  ```
* **Placement:**
  On **every meal card**, under:

  * Add to Plan
  * Add to Macros
    (same position everywhere)

No branching logic. No builder-specific versions.

---

## âœ… PHASE 3: Routing (this is the key insight)

### You do NOT create multiple pages

You create **one Prepare Mode entry point**.

Two valid approaches â€” pick **A** (recommended):

### âœ… A) Shared Prepare Mode Route

```
/prepare/:mealId
```

What gets passed:

* meal object (or mealId â†’ hydrate from store)
* source (craving, planner, kids, etc.)
* readOnly = true

This keeps everything centralized.

---

## âœ… PHASE 4: Prepare Mode UX (Phase Two feature)

### Structure (simple, calm, powerful)

**Header**

* Meal name
* Medical badges
* Servings
* Optional timer icon

**Step List (auto-generated)**

1. Prep
2. Cooking
3. Waiting (timers)
4. Plating / Serving

Each step:

* Instruction text
* Optional â€œListen to Chefâ€
* Optional timer
* Next / Back controls
* Pause / Resume state

---

## âœ… PHASE 5: Intelligence (light, not heavy AI)

This is **not** generation. Itâ€™s enhancement.

### Behind the scenes:

* Parse existing instructions
* Auto-detect:

  * durations (â€œcook 20 minutesâ€)
  * rest times
  * temperature cues
* Attach timers automatically
* Allow manual override

No LLM calls required initially.

---

## âœ… PHASE 6: Exit Paths (important UX detail)

From Prepare Mode, user can:

* âœ… Finish cooking â†’ **Back to meal card**
* âœ… Cook again later (state persists)
* âœ… Create New Meal (explicit action only)

Meal is **never destroyed automatically**.

---

## âœ… PHASE 7: Copilot Script (tone you want)

This is NOT clinical.

Chef tone:

* Confident
* Friendly
* Calm
* â€œIâ€™ve got youâ€

Example opening:

> â€œAlright, letâ€™s cook. Iâ€™ll walk you through this step by step. Take your time â€” Iâ€™m right here.â€

---

## ðŸ”’ Architectural Rule (write this down)

> **Any meal card with instructions automatically supports Prepare with Chef.**

This makes the feature:

* Future-proof
* Builder-agnostic
* Impossible to forget later

---

## What we do next (your call)

Say the word and I will:

1. **Design the Prepare Mode component contract**
2. **Write the exact props interface**
3. **Map how existing meal cards hook into it**
4. **Draft the Copilot scripts for Phase Two**
5. **Create a rollout checklist for Apple (this feature is review-safe)**

Youâ€™re not just adding a feature â€”
youâ€™re turning meals into **experiences**.

Whenever youâ€™re ready: **next**.
