Good, this is exactly the right time to wire this up.

You already had the architect say:

> ❌ No walkthroughs
> ❌ No Copilot integration for this flow
> ❌ No WalkthroughRegistry entries for these routes

So I’m going to **fill those holes** for the CareTeam + Pro → Client → Biometrics → Builders path.

Below is everything your architect needs:

* Copilot walkthrough scripts (what the boxes actually say, in order)
* Event trigger map (what events each page must fire, with testIds)
* State machine skeleton (how Copilot knows which walkthrough to run)
* Registry entries (how your global Copilot knows what to load per route)

You can hand this straight to the dev/agent.

---

## 1️⃣ Global helper – how pages should fire walkthrough events

You’re already doing this in Alcohol Log:

```ts
setTimeout(() => {
  const event = new CustomEvent("walkthrough:event", {
    detail: { testId: "alcohollog-added", event: "done" },
  });
  window.dispatchEvent(event);
}, 300);
```

Standardize it like this:

```ts
// client/src/lib/walkthroughEvents.ts
export function emitWalkthrough(testId: string, event: string = "done") {
  window.dispatchEvent(
    new CustomEvent("walkthrough:event", {
      detail: { testId, event },
    })
  );
}
```

Use that in all CareTeam / Pro / Biometrics screens.

---

## 2️⃣ WalkthroughRegistry entries – CareTeam & Pro flow

Assuming you already have a `WalkthroughRegistry` object somewhere, extend it like this.

```ts
// client/src/features/copilot/walkthroughRegistry.ts

export type WalkthroughStep = {
  id: string;
  testId?: string;        // UI element testId this step is “about”
  text: string;           // Copilot box text
  hint?: string;          // optional smaller text
  waitFor?: {
    testId: string;
    event?: string;       // default "done"
  };
};

export type WalkthroughConfig = {
  id: string;
  route: string;
  role: "client" | "coach" | "pro";
  steps: WalkthroughStep[];
};

export const walkthroughRegistry: WalkthroughConfig[] = [
  // 1) CLIENT: join CareTeam with a code
  {
    id: "careteam-client-join",
    route: "/care-team",
    role: "client",
    steps: [
      {
        id: "intro",
        text: "Enter the code your coach or doctor gave you. This links your app to their CareTeam portal.",
        testId: "input-careteam-code",
        hint: "Paste or type the code, then tap Connect.",
      },
      {
        id: "submit-code",
        text: "Now tap Connect to link your account.",
        testId: "button-submit-careteam-code",
        waitFor: { testId: "careteam-link-success" },
      },
      {
        id: "linked",
        text: "Nice. You're now connected to your professional. Next we’ll set up your profile so they can build perfect meals for you.",
        waitFor: { testId: "button-start-onboarding" },
      },
    ],
  },

  // 2) PRO: manage clients list, open a client dashboard
  {
    id: "pro-clients-list",
    route: "/pro/clients",
    role: "pro",
    steps: [
      {
        id: "intro",
        text: "This is your client list. Pick a client to open their dashboard.",
        testId: "pro-client-row",
        hint: "Tap Open on the client you want to work with.",
      },
      {
        id: "open-client",
        text: "Tap Open to configure macros and meal targets for this client.",
        testId: "button-open-client",
        waitFor: { testId: "pro-client-dashboard-opened" },
      },
    ],
  },

  // 3) PRO: client dashboard – set macros and push to biometrics
  {
    id: "pro-client-macros",
    route: "/pro/clients/:id",
    role: "pro",
    steps: [
      {
        id: "intro",
        text: "Set this client’s core targets: calories, protein, carbs, and fats.",
        testId: "form-client-macros",
        hint: "Use your usual coaching numbers or clinical presets.",
      },
      {
        id: "save-macros",
        text: "When you're done, Save these macros.",
        testId: "button-save-macros",
        waitFor: { testId: "pro-macros-saved" },
      },
      {
        id: "send-to-biometrics",
        text: "Now push these macros into the client’s biometrics so the app can use them everywhere.",
        testId: "button-send-macros-to-biometrics",
        waitFor: { testId: "pro-macros-sent-to-biometrics" },
      },
      {
        id: "next-step",
        text: "Perfect. Now you or your client can use the meal builders with these guardrails.",
        hint: "From here, you can open a meal builder or tell your client to use Smart Menu, One-Pan, or AI Premades.",
      },
    ],
  },

  // 4) CLIENT: Biometrics with pro-set macros applied
  {
    id: "client-biometrics-pro-macros",
    route: "/my-biometrics",
    role: "client",
    steps: [
      {
        id: "intro",
        text: "These are your current macros and biometrics. Your coach or doctor can update them remotely.",
        testId: "section-biometrics-summary",
      },
      {
        id: "confirm",
        text: "Review your numbers. When everything looks right, Save or Continue.",
        testId: "button-save-biometrics",
        waitFor: { testId: "biometrics-saved" },
      },
      {
        id: "go-to-builders",
        text: "You're set. Open your Meal Builders to start using these targets.",
        testId: "button-open-meal-builders",
      },
    ],
  },
];
```

You can merge this into your existing registry rather than replacing it.

---

## 3️⃣ Event Trigger Map – what each page must emit

Here’s exactly what each page should fire for Copilot to advance steps.

### A) `/care-team` (client join)

Elements + testIds:

* Code input: `data-testid="input-careteam-code"`
* Submit/Connect button: `data-testid="button-submit-careteam-code"`
* After successful link: **emit** `careteam-link-success`
* Button to start onboarding wizard: `data-testid="button-start-onboarding"`

In code:

```tsx
import { emitWalkthrough } from "@/lib/walkthroughEvents";

function handleJoinSuccess() {
  // after backend confirms link
  emitWalkthrough("careteam-link-success");
  // then maybe route to onboarding start
  // setLocation("/onboarding/start");
}
```

---

### B) `/pro/clients` (pro client list)

* Each row: `data-testid="pro-client-row"`
* Open button: `data-testid="button-open-client"`
* When client dashboard opens: **emit** `pro-client-dashboard-opened` on that page load

In `ProClientsPage`:

```tsx
<button
  data-testid="button-open-client"
  onClick={() => setLocation(`/pro/clients/${client.id}`)}
>
  Open
</button>
```

In `ProClientDashboardPage`:

```tsx
useEffect(() => {
  emitWalkthrough("pro-client-dashboard-opened");
}, []);
```

---

### C) `/pro/clients/:id` (pro client macros)

* Macros form wrapper: `data-testid="form-client-macros"`
* Save button: `data-testid="button-save-macros"`
* “Send Macros to Biometrics” button: `data-testid="button-send-macros-to-biometrics"`

In save handler:

```tsx
async function handleSaveMacros() {
  await saveMacrosToServer();
  emitWalkthrough("pro-macros-saved");
}
```

In send-to-biometrics handler:

```tsx
async function handleSendToBiometrics() {
  await sendMacrosToBiometrics();
  emitWalkthrough("pro-macros-sent-to-biometrics");
}
```

---

### D) `/my-biometrics` (client side)

* Summary: `data-testid="section-biometrics-summary"`
* Save button: `data-testid="button-save-biometrics"`
* Button/Link to builders: `data-testid="button-open-meal-builders"`

On save:

```tsx
async function handleSaveBiometrics() {
  await saveBiometrics();
  emitWalkthrough("biometrics-saved");
}
```

---

## 4️⃣ Copilot State Machine – high-level config

This is how your global Copilot can decide **which walkthrough to run**.

```ts
// client/src/features/copilot/copilotStateMachine.ts

export type CopilotMode =
  | "off"
  | "careteam-client-join"
  | "pro-clients"
  | "pro-client-macros"
  | "client-biometrics";

export interface CopilotContext {
  role: "client" | "pro" | "coach";
  hasCareteamLink: boolean;
  hasProMacros: boolean;
  route: string;
}

export function resolveCopilotMode(ctx: CopilotContext): CopilotMode {
  if (ctx.role === "client") {
    if (!ctx.hasCareteamLink && ctx.route === "/care-team") {
      return "careteam-client-join";
    }
    if (ctx.route === "/my-biometrics") {
      return "client-biometrics";
    }
    return "off";
  }

  if (ctx.role === "pro" || ctx.role === "coach") {
    if (ctx.route === "/pro/clients") return "pro-clients";
    if (ctx.route.startsWith("/pro/clients/")) return "pro-client-macros";
    return "off";
  }

  return "off";
}
```

Your Copilot UI reads:

* current route
* current role
* CareTeam link status
* very basic flags

…then loads the matching `walkthroughRegistry` entry if **Copilot is toggled on**.

---

## 5️⃣ Copilot UI – always-on until user disables

You said:

> as long as the copilot is on, the person is always going to have that copilot walkthrough any page until the page opens unless that person cuts it off.

So your Copilot component should roughly:

```tsx
// client/src/features/copilot/CopilotShell.tsx

import { walkthroughRegistry } from "./walkthroughRegistry";
import { resolveCopilotMode } from "./copilotStateMachine";

export function CopilotShell({ route, role, hasCareteamLink, hasProMacros }: Props) {
  const [enabled, setEnabled] = useState(true);
  const [currentStepId, setCurrentStepId] = useState<string | null>(null);

  const mode = resolveCopilotMode({ route, role, hasCareteamLink, hasProMacros });

  const config = walkthroughRegistry.find((w) => w.id === mode);

  // listen to walkthrough events
  useEffect(() => {
    if (!enabled || !config) return;

    function onEvent(e: CustomEvent<{ testId: string; event: string }>) {
      const { testId, event } = e.detail;
      const step = config.steps.find(
        (s) => s.waitFor && s.waitFor.testId === testId && (s.waitFor.event ?? "done") === event
      );
      if (!step) return;
      const idx = config.steps.findIndex((s) => s.id === step.id);
      const next = config.steps[idx + 1];
      if (next) setCurrentStepId(next.id);
    }

    window.addEventListener("walkthrough:event", onEvent as any);
    return () => window.removeEventListener("walkthrough:event", onEvent as any);
  }, [enabled, config]);

  useEffect(() => {
    // whenever route/mode changes, reset to first step
    if (config && enabled) {
      setCurrentStepId(config.steps[0].id);
    } else {
      setCurrentStepId(null);
    }
  }, [config?.id, enabled]);

  if (!enabled || !config || !currentStepId) return null;

  const step = config.steps.find((s) => s.id === currentStepId);
  if (!step) return null;

  return (
    <CopilotBubble
      text={step.text}
      hint={step.hint}
      onNext={() => {
        const idx = config.steps.findIndex((s) => s.id === step.id);
        const next = config.steps[idx + 1];
        if (next) setCurrentStepId(next.id);
      }}
      onClose={() => setEnabled(false)}
    />
  );
}
```

That ties directly into the “boxes around it with next, next, next” behavior you described.

---

## 6️⃣ What’s still missing / what the architect should do next

For the architect/dev, the todo list is now clear:

1. **Add `emitWalkthrough()` helper** and start using it instead of ad-hoc CustomEvents.
2. **Add the WalkthroughRegistry entries** above to your existing registry file.
3. **Wire event emissions** on:

   * CareTeam code success
   * Pro macros saved
   * Pro macros sent to biometrics
   * Biometrics saved
   * Pro client dashboard open
4. **Implement the CopilotShell** (or plug this logic into your existing Copilot container).
5. **Feed CopilotShell** the route + role + flags from your app-level context.
6. **Add the global Copilot toggle** (on/off) that controls whether walkthroughs show.

---

If you want, next move I can do is **expand this same pattern to one of the main builders** (Smart Menu or One-Pan) so the architect sees *end-to-end*:

CareTeam → Pro macros → Biometrics → Builder walkthrough all wired to Copilot.
