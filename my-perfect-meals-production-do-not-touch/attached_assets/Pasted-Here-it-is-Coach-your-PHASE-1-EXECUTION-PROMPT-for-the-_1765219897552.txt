Here it is, Coach ‚Äî your PHASE 1 EXECUTION PROMPT for the Replit Agent / Architect.
This is surgical, directive, and foolproof, and it includes a built-in request for the architect to flag ANY conflicts or issues before proceeding.

You can copy/paste this EXACTLY into Replit.

‚∏ª

‚úÖ PHASE 1 ‚Äî EXECUTION PROMPT FOR ARCHITECT / AGENT

Architect, load full My Perfect Meals context and all prior directives.
This is a Phase 1 implementation order. Do not skip steps.
If ANYTHING in this implementation conflicts with existing architecture, naming, or guardrails, STOP and report back before executing.

‚∏ª

üî• PHASE 1 GOAL

Implement the new CreateWithChef feature across ALL meal generators (breakfast, lunch, dinner) by reusing the existing Fridge Rescue system.

This phase does not touch snacks.
Snacks will be handled in Phase 2 under the new name SnackCreator.

‚∏ª

üß© WHAT YOU ARE BUILDING (PHASE 1 ONLY)

1. CreateWithChefButton

A new button component that replaces ‚ÄúAI Premades‚Äù everywhere it appears.
	‚Ä¢	Uses existing button styling conventions.
	‚Ä¢	Should not introduce new style systems.
	‚Ä¢	Label: ‚ÄúCreate With Chef‚Äù
	‚Ä¢	Icon: Use existing Chef-related iconography already in the project (signature branding).

‚∏ª

2. CreateWithChefModal

A new modal component modeled after Fridge Rescue‚Äôs UI:
	‚Ä¢	Black-glass modal
	‚Ä¢	One text input box
	‚Ä¢	Placeholder example:
‚ÄúDescribe what you want: ‚Äòsweet eggs,‚Äô ‚Äòprotein pancakes,‚Äô ‚Äòlow-carb tacos,‚Äô etc.‚Äù
	‚Ä¢	One Generate button
	‚Ä¢	Close button

NO PICKERS.
NO CATEGORY SELECTORS.
NO INGREDIENT INPUT LOGIC.
NO MEAL BUILDER STEPS.
Modal only accepts free-form text.

‚∏ª

3. Backend Action ‚Äî Reuse Fridge Rescue Engine

The CreateWithChef modal should pipe its request through:

Fridge Rescue ‚Üí guardrails ‚Üí unified meal card builder ‚Üí output.

NO new prompts.
NO new adapters.
NO new inference types.

Just reuse the existing Fridge Rescue transformation logic.

If needed, create a small adapter hook name:

useCreateWithChefRequest()

‚Ä¶but it should ultimately call the same engine Fridge Rescue uses.

‚∏ª

üîß WHAT YOU MUST REMOVE / DISABLE (PHASE 1)

Immediately hide, disable, or remove from UI:
	‚Ä¢	AI Premade button
	‚Ä¢	Any AI Premade associated modal
	‚Ä¢	Premade logic references in any builder

Do not remove files yet.
Full deletion is Phase 3.

‚∏ª

üóÇ FILES TO CREATE

client/src/components/CreateWithChefButton.tsx
client/src/components/CreateWithChefModal.tsx
client/src/hooks/useCreateWithChefRequest.ts (optional; thin wrapper)


‚∏ª

üìå INTEGRATION TARGETS (ALL IN PHASE 1)

Create With Chef must appear inside:
	‚Ä¢	General Nutrition Builder
	‚Ä¢	Weekly Meal Builder
	‚Ä¢	Diabetic Builder
	‚Ä¢	GLP-1 Builder
	‚Ä¢	Anti-Inflammatory Builder
	‚Ä¢	Beachbody / Body Physique Builder
	‚Ä¢	Performance & Competition Builders
	‚Ä¢	ProCare professional boards
	‚Ä¢	Any builder using breakfast/lunch/dinner sections

Insert the button next to where AI Premades currently exists.

‚∏ª

üß™ STABILITY REQUIREMENTS

Architect must ensure:
	‚Ä¢	No mutation of Fridge Rescue pipeline. Only reuse.
	‚Ä¢	No breakage of MealCard rendering.
	‚Ä¢	Macros must calculate exactly the same as Fridge Rescue meals.
	‚Ä¢	iOS Capacitor wrappers must display modal correctly.
	‚Ä¢	No new dependencies added.

‚∏ª

üö® STOP CONDITION (MANDATORY)

Architect must halt and report if:
	‚Ä¢	Any builder‚Äôs layout can‚Äôt accept the new button cleanly
	‚Ä¢	Any backend logic creates conflicts with Fridge Rescue‚Äôs guardrails
	‚Ä¢	Any modal conflicts with iOS overlay rules
	‚Ä¢	Any existing naming collisions are detected
	‚Ä¢	Any pre-existing FE/BE errors appear that weren‚Äôt seen before

Architect must NOT auto-refactor or invent alternatives.

‚∏ª

üßë‚Äçüç≥ BRANDING NOTE

We are standardizing on the word Chef as the signature identity of the app.
	‚Ä¢	CreateWithChef (meals)
	‚Ä¢	SnackCreator (snacks, Phase 2)
	‚Ä¢	CravingCreator (already exists)
	‚Ä¢	DessertCreator (already exists)

Architect must preserve these names and not alter them.

‚∏ª

üèÅ EXECUTION INSTRUCTIONS

Architect, acknowledge this plan as loaded and ready.

Then:
	1.	Validate UI injection points.
	2.	Check for potential conflicts.
	3.	Report back ANY blockers or concerns.
	4.	If no blockers, begin PHASE 1 implementation following the exact structure above.

Do NOT proceed silently.
Confirm blockers OR thumbs-up readiness FIRST.

‚∏ª

Coach ‚Äî this is airtight.
Drop this into Replit and the agent will know exactly what to do, without drifting, without inventing features, and without breaking anything.

If you‚Äôd like, I can also prepare the Phase 2 Execution Prompt (SnackCreator) so it‚Äôs ready to go right after Phase 1 passes review.