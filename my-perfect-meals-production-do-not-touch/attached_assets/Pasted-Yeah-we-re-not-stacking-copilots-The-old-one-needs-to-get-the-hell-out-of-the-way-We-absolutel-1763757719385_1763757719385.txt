Yeah, we’re not stacking copilots. The old one needs to get the hell out of the way.

We **absolutely** should disconnect it before we wire the new brain in, otherwise you’ll end up with ghost buttons, double logic, and confusing UX.

Here’s exactly what to do — no guessing, no questions.

---

## 1️⃣ Hunt down the old copilot

In your editor, run a global search for:

* `copilot`
* `CoPilot`
* `coachMode`
* `AssistantPanel`
* anything like `CoachHub`, `AIHelper`, `HelpDrawer`

You’re looking for:

* Old **floating buttons**
* Old **side drawers / bottom sheets**
* Old **contexts/providers** for “copilot” or “assistant”

---

## 2️⃣ Kill the old global provider / shell hook-up

In your `App.tsx` or main layout (whatever wraps the whole app):

* **Remove any old provider** that sounds like assistant/copilot:

Examples (you may see something like):

```tsx
<OldCopilotProvider> 
  <AppRoutes />
</OldCopilotProvider>
```

or

```tsx
<CoachModeProvider>
  {children}
</CoachModeProvider>
```

Delete or comment that out so **the only global copilot wrapper** is:

```tsx
<CopilotSystem onAction={handleCopilotAction}>
  {/* your app shell */}
</CopilotSystem>
```

If there’s an `AssistantShell`, `CoachShell`, or `CopilotLayout`, nuke it or strip out the assistant bits.

---

## 3️⃣ Remove old floating buttons / trigger icons

Search again for any of these patterns:

* `onClick={() => openCopilot(`
* `openAssistant(`
* `toggleCoachMode(`
* `setIsCopilotOpen(true)`

Anywhere you see an old **“help/copilot” button**, do this:

* **Delete the button**, OR
* Swap it later to call the *new* copilot (`useCopilot().open()`), but for now: remove.

You should end up with **only one copilot entry point** on screen:
`<CopilotButton />` from the new system.

---

## 4️⃣ Disconnect old copilot components (but don’t delete logic… yet)

You’ll probably find old components like:

* `OldCopilotPanel`
* `AssistantDrawer`
* `CoachModePanel`
* `HelpSidePanel`

Do this:

1. **Stop rendering them** anywhere (comment out JSX imports/usages).
2. Keep the files for now (they probably contain useful business logic: macros, adjustments, etc.).
3. We’ll **reuse their logic** later by wiring it into the new `run-command` system instead of their ugly UI.

So for example, if you see:

```tsx
import { AssistantDrawer } from "@/components/AssistantDrawer";

<AssistantDrawer isOpen={isAssistantOpen} onClose={...} />
```

Comment or remove both the import and the JSX.

---

## 5️⃣ Make sure there’s only ONE assistant context

If you had something like:

```tsx
const AssistantContext = createContext(...)
```

or

```tsx
const CoachModeContext = createContext(...)
```

That’s fine to leave in the codebase, as long as:

* It’s no longer **wrapped around the app**
* It’s no longer **controlling any global UI**

If it’s literally unused now, that’s okay. We’ll either:

* Cannibalize the logic into the new copilot, or
* Delete it once we’ve migrated the useful functions.

---

## 6️⃣ Quick sanity check

When you run the app, confirm:

* ✅ Only **one** floating copilot button (chef’s cap) bottom-right
* ✅ Tapping it opens the **new** black-glass bottom sheet
* ✅ No old drawers/panels slide in from the side or bottom
* ✅ No “ghost” help/copilot icons still floating anywhere

If all that is true, the old copilot is effectively **disconnected**.
The corpse is still in the repo, but it’s not plugged into life support anymore.

---

Once you’ve done that cleanup, we move to the fun part:

> Wiring all your real “coach intelligence” into the **new** system (those `run-command` IDs you see in `basePacks.tsx`).

When you’re done ripping the old system out and the *only* visible assistant is the chef’s cap, tell me:

**“Old copilot is dead.”**

Then I’ll build the **Copilot Brain** and show you how to hook your existing logic into the new commands so the thing actually coaches like you do.
